cmake_minimum_required(VERSION 3.5)
project(ubiquity_motor_ros2)

if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
  add_compile_options(-Wall -Wextra -Wpedantic)
endif()

# Find dependencies
find_package(ament_cmake REQUIRED)
find_package(rosidl_default_generators REQUIRED)
find_package(rclcpp REQUIRED)
find_package(std_msgs REQUIRED)
find_package(sensor_msgs REQUIRED)
find_package(hardware_interface REQUIRED)
find_package(ros2_control REQUIRED)
find_package(diagnostic_updater REQUIRED)
find_package(serial REQUIRED)



# ROS 2 message generation
# rosidl_generate_interfaces(${PROJECT_NAME}
#   "msg/MotorState.msg"
#   DEPENDENCIES std_msgs
# )

# Include directories
include_directories(
  include
)



# Build the library containing reusable code
# add_library(ubiquity_motor
#   src/motor_message.cc
#   src/motor_serial.cc
#   src/motor_hardware.cc
# )

# Link the generated messages to the library
# ament_target_dependencies(ubiquity_motor
#   "rclcpp"
#   "std_msgs"
#   "sensor_msgs"
#   "hardware_interface"
#   "ros2_control"
#   "diagnostic_updater"
# )

# Add executable
add_executable(motor_node src/motor_node.cc)

# add_dependencies(motor_node ${PROJECT_NAME}_interfaces)

# Link the generated messages and the library to the executable
# target_link_libraries(motor_node ubiquity_motor)

ament_target_dependencies(motor_node
  "rclcpp"
  "std_msgs"
  "sensor_msgs"
  "hardware_interface"
  "ros2_control"
  "diagnostic_updater"
)

ament_export_dependencies(rosidl_default_runtime)

# # Install the library and executable
install(TARGETS
  motor_node
  #ubiquity_motor
  DESTINATION lib/${PROJECT_NAME}
)

# # Install any Python scripts (if any)
# install(PROGRAMS
#   scripts/upgrade_firmware.py
#   scripts/test_motor_board.py
#   scripts/test_pi_gpio.py
#   DESTINATION lib/${PROJECT_NAME}
# )

# Finish up the package
ament_package()